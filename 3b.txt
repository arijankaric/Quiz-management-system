Zbog randomizacije/generisanja parova elemenata iz iste kategorije,
najjednostavnije bi bilo imati posebnu tabelu za svaku kategoriju.
Tako da u prvom koraku randomizacije odredimo za koju od 5 kategorija se glasa.
A nakon toga se poziva za odabranu kategoriju funkcija kojom dobijamo nasumicni
par elemenata za nasumicno odabranu kategoriju. Sheme za tabele za nove kategorije
mogle bi biti identicne kao za video(string za link(na tweet, instagram post), 
string za naziv, int za pozitivne i totalne glasove i rank).
Dakle, odvojene tabele za svaku kategoriju su cisto zbog optimalnog generisanja
parova iz iste kategorije

Ukoliko zelimo sortirati po ranku zajedno sve kategorije zbog toga imamo JOIN.
Ako zelimo zajednicku rankings stranicu naprimjer ili admin stranicu gdje su prikazane
sve kategorije ili da se ima opcija odabira koje tabele ce se joinati/prikazati na datom
pageu.

Forma za dodavanje/modificiranje videa entitija se moze generalizovati za sve kategorije
tako sto dodamo jos jedno polje tipa radio. 
Kada modificiramo YTVideo, vec je odabran YTVideo radibutton
<input type="radio" id="YTVideo" name="category" value="YTVideo" checked="checked">

Dakle, 

<input type="radio" id="YTVideo" name="category" value="YTVideo">
<label for="YTVideo">YTVideo</label><br>
<input type="radio" id="Tweet" name="category" value="Tweet">
<label for="Tweet">Tweet</label><br>
<input type="radio" id="javascript" name="category" value="IGPost">
<label for="IGPost">IGPost</label>

je potrebno dodati POST formi.

Naravno treba uvesti i pored regex provjere za youtube link, regex provjere za svaku
od dodanih kategorija.

VideoDAO funkcije mozemo generalizovati tako sto cemo proslijediti dodatni parametar int
koji ce funkciji kazati za koju tabelu se poziva funkcija. Naprimjer funkcija 
public ArrayList<?> getRandomVideos(int whichTable)
{
	EntityManager em = createEntityManager();
	Query q = null;
	String queryStr = null;
	int rand1 = new Random().nextInt(100000); int rand2;
	while(rand1 == (rand2 = new Random().nextInt(100000)))
			;
	switch(whichTable)
	{
		case 0:
		queryStr = "SELECT v FROM Video v";
		q = em.createQuery(queryStr);
		q.setMaxResults(1);
		q.setFirstResult(rand1);
		Video video1 = (Video) q.getSingleResult();
		q.setFirstResult(rand2);
		Video video2 = (Video) q.getSingleResult();
		ArrayList<Video> resultList = new ArrayList<>();
		resultList.add(video1);
		resultList.add(video2);
		return resultList;
		break;
		case 1:
		queryStr = "SELECT t FROM Tweet t";
		q = em.createQuery(queryStr);
		q.setMaxResults(1);
		q.setFirstResult(rand1);
		Tweet tweet1 = (Tweet) q.getSingleResult();
		q.setFirstResult(rand2);
		Tweet tweet2 = (Tweet) q.getSingleResult();
		ArrayList<Tweet> resultList = new ArrayList<>();
		resultList.add(tweet1);
		resultList.add(tweet2);
		return resultList;
		break;
		case 2:
		// za ostale kategorije
		// ...
		default:
		//greska?
	}
	
}
I ostale funkcije koje pripadaju klasama Video* mogu se na slican nacin generalizovati

Takodjer potrebno je i na klijentskoj strani cuvati kad se dobije od servera koja kategorija
je u pitanju, tako da kada se glasa da server/servlet zna odmah sta da ocekuje na osnovu
povratne informacije sa klijentske strane, da li je u pitanju tweet ili instagram post
da ne mora da parsira.
